name: Python package

on:
  push:
    branches:
      - master
      - dev
  pull_request:

jobs:
  django:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python:
#           - 3.6
          - "3.10"
        django:
#           - "==2.2.*"
          - "==4.2.*"
    steps:
    - uses: actions/checkout@v4
    # Pull the latest image to build, and avoid caching pull-only images.
    # (docker pull is faster than caching in most cases.)
    - run: |
        docker compose --file docker-compose.yml --file docker-compose.test.yml pull
        docker pull python:${{matrix.python}}-slim
    - name: Start database early
      run: docker compose up -d db
    - name: Build application
      run: make build
      env:
        PYTHON_VERSION: ${{ matrix.python }}
    - name: Migration check
      run: make check
    - name: Show settings
      run: make settings

    - name: Regenerate frontend with gulp service
      run: |
        docker compose -f docker-compose.yml run web python manage.py collectstatic --no-input
        docker compose -f docker-compose.yml up gulp

    - name: Check for Changes in Static Files
      run: |
        git status
        if ! git diff --quiet poradnia/static/; then
          git diff
          echo "Static files needs to be updated. Exiting with code 1"
          exit 1

          # # Configure Git user for committing changes
          # git config --global user.name "GitHub Actions"
          # git config --global user.email "actions@github.com"
          # git fetch origin
          # echo "Checkout to ${{ github.event.pull_request.head.ref }} branch"
          # git checkout -b ${{ github.event.pull_request.head.ref }}
          # echo "Set ${{ github.event.pull_request.head.ref }} upstream"
          # git branch --set-upstream-to=origin/${{ github.event.pull_request.head.ref }} ${{ github.event.pull_request.head.ref }}
          # git status
          # echo "Stash changes on ${{ github.event.pull_request.head.ref }}"
          # git stash
          # echo "Pull ${{ github.event.pull_request.head.ref }} from origin"
          # git pull
          # echo "Pop stashed changes on ${{ github.event.pull_request.head.ref }}"
          # git stash pop
          # # Stage and commit the changes
          # git status 
          # git add .
          # git commit -m "Update static files after dependency change"
          # git status
          # git push
          # echo "Checkout back to $GITHUB_SHA commit"
          # git checkout $GITHUB_SHA
          # git status

          # # Fetch the latest remote changes for the base branch
          # echo "Fetching latest changes for the base branch..."
          # git fetch origin
          # git pull --no-rebase origin ${{ github.event.pull_request.head.ref }}

          # # Rebase onto the base branch to ensure the branch is up-to-date
          # echo "Rebasing changes onto the base branch..."
          # if ! git rebase origin/${{ github.event.pull_request.base.ref }}; then
          #   echo "Rebase encountered conflicts. Attempting to resolve automatically..."

          #   # Show conflicts
          #   echo "Conflicted files:"
          #   git diff --name-only --diff-filter=U

          #   # Show detailed conflict information
          #   echo "Detailed conflict information:"
          #   git diff --diff-filter=U

          #   # Automatically resolve conflicts using theirs strategy for binary files
          #   git diff --name-only --diff-filter=U | while read file; do
          #     echo "Resolving conflict in $file using 'ours' strategy."
          #     git checkout --ours "$file" || echo "Failed to resolve conflict in $file"
          #     git add "$file"
          #   done

          #   # Continue the rebase
          #   if git rebase --continue; then
          #     echo "Rebase completed after resolving conflicts."
          #   else
          #     echo "Rebase failed despite conflict resolution. Please resolve manually."
          #     exit 1
          #   fi
          # fi
          
          # Push the changes back to the branch with safety
          # echo "Pushing changes back to the branch associated with the PR."
          # git push --force-with-lease origin HEAD:${{ github.event.pull_request.head.ref }} || {
          #   echo "Push failed. Ensure no conflicts or simultaneous pushes occurred.";
          #   exit 1;
          # }

          # echo "Static files changes have been successfully pushed."
        else
          echo "No changes in static files."
        fi
  
    - name: Run unit tests
      run: make test
    - name: Run e2e tests
      run: make e2e

  docs:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    - run: docker compose pull
    - name: Build application
      run: make build
    - name: Build documentation
      run: make docs
